<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Pianeti del Sistema Solare - Texture e Luce POV</title>
    <style>
        body { margin: 0; background-color: #000; font-family: 'Segoe UI', sans-serif; color: #fff; text-align: center; }
        h1 { margin: 20px 0; font-weight: 300; font-size: 2.5em; }
        #reset-view-btn {
            padding: 10px 20px;
            font-size: 16px;
            font-weight: bold;
            color: #fff;
            background-color: #007BFF;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            margin-bottom: 20px;
            transition: background-color 0.3s;
        }
        #reset-view-btn:hover {
            background-color: #0056b3;
        }
        #grid-container { display: grid; grid-template-columns: repeat(3, 1fr); gap: 20px; padding: 20px; max-width: 1200px; margin: 0 auto; }
        .planet-cell { background-color: #1a1a1a; border: 1px solid #333; border-radius: 8px; padding: 15px; }
        .planet-cell h2 { margin: 0 0 10px 0; font-weight: 400; color: #00aaff; }
        .canvas-container { width: 100%; aspect-ratio: 1 / 1; cursor: grab; margin-bottom: 10px; background-color: #000; }
        .planet-data { font-family: monospace; font-size: 14px; color: #ccc; }
        @media (max-width: 900px) { #grid-container { grid-template-columns: repeat(2, 1fr); } }
        @media (max-width: 600px) { #grid-container { grid-template-columns: 1fr; } }
    </style>
</head>
<body>

    <h1>Pianeti in Rotazione con Texture</h1>
    <button id="reset-view-btn">Reset Visuale</button>

    <div id="grid-container">
        <div class="planet-cell"> <h2>Mercurio</h2> <div class="canvas-container" id="mercury-canvas"></div> <div class="planet-data"> Rotazione: 58.6 giorni </div> </div>
        <div class="planet-cell"> <h2>Venere</h2> <div class="canvas-container" id="venus-canvas"></div> <div class="planet-data"> Rotazione: -243 giorni </div> </div>
        <div class="planet-cell"> <h2>Terra</h2> <div class="canvas-container" id="earth-canvas"></div> <div class="planet-data"> Rotazione: 1 giorno </div> </div>
        <div class="planet-cell"> <h2>Marte</h2> <div class="canvas-container" id="mars-canvas"></div> <div class="planet-data"> Rotazione: 1.03 giorni </div> </div>
        <div class="planet-cell"> <h2>Giove</h2> <div class="canvas-container" id="jupiter-canvas"></div> <div class="planet-data"> Rotazione: 0.41 giorni </div> </div>
        <div class="planet-cell"> <h2>Saturno</h2> <div class="canvas-container" id="saturn-canvas"></div> <div class="planet-data"> Rotazione: 0.44 giorni </div> </div>
        <div class="planet-cell"> <h2>Urano</h2> <div class="canvas-container" id="uranus-canvas"></div> <div class="planet-data"> Rotazione: -0.72 giorni </div> </div>
        <div class="planet-cell"> <h2>Nettuno</h2> <div class="canvas-container" id="neptune-canvas"></div> <div class="planet-data"> Rotazione: 0.67 giorni </div> </div>
        <div class="planet-cell"> <h2>Plutone</h2> <div class="canvas-container" id="pluto-canvas"></div> <div class="planet-data"> Rotazione: -6.39 giorni </div> </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';

        document.addEventListener('DOMContentLoaded', () => {

            const PLANET_DATA = {
                mercury: { rotationDays: 58.6,  radius: 0.38, axialTilt: 0.03,  textureUrl: 'https://threejs.org/examples/textures/planets/mercurymap.jpg' },
                venus:   { rotationDays: -243,   radius: 0.95, axialTilt: 177.4, textureUrl: 'https://threejs.org/examples/textures/planets/venusmap.jpg' },
                earth:   { rotationDays: 1,      radius: 1.0,  axialTilt: 23.44, textureUrl: null }, // Modello speciale
                mars:    { rotationDays: 1.03,   radius: 0.53, axialTilt: 25.19, textureUrl: 'https://threejs.org/examples/textures/planets/mars_1k_color.jpg' },
                jupiter: { rotationDays: 0.41,   radius: 1.8,  axialTilt: 3.13,  textureUrl: 'https://threejs.org/examples/textures/planets/jupitermap.jpg' },
                saturn:  { rotationDays: 0.44,   radius: 1.6,  axialTilt: 26.73, textureUrl: 'https://threejs.org/examples/textures/planets/saturnmap.jpg', ringTextureUrl: 'https://threejs.org/examples/textures/planets/saturnring.png' },
                uranus:  { rotationDays: -0.72,  radius: 1.2,  axialTilt: 97.77, textureUrl: 'https://threejs.org/examples/textures/planets/uranusmap.jpg' },
                neptune: { rotationDays: 0.67,   radius: 1.1,  axialTilt: 28.32, textureUrl: 'https://threejs.org/examples/textures/planets/neptunemap.jpg' },
                pluto:   { rotationDays: -6.39,  radius: 0.3,  axialTilt: 119.6, textureUrl: 'https://threejs.org/examples/textures/planets/plutomap1k.jpg' }
            };

            const scenesToAnimate = [];
            const textureLoader = new THREE.TextureLoader();
            const continentMaterial = new THREE.MeshStandardMaterial({ color: 0x6C8A4D, flatShading: true, roughness: 0.9 });

            function createPlanetScene(container, id) {
                const data = PLANET_DATA[id];
                const scene = new THREE.Scene();
                const camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 1000);
                const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                container.appendChild(renderer.domElement);

                // --- ILLUMINAZIONE: LUCE POV COME UN SOLE ---
                scene.add(new THREE.AmbientLight(0xffffff, 0.4)); // Luce ambientale per riempire le ombre
                
                const directionalLight = new THREE.DirectionalLight(0xffffff, 1.5); // Luce direzionale (il "sole")
                // Posiziona la luce nella stessa posizione della telecamera
                // e la fa puntare al centro (0,0,0) dove si trova il pianeta.
                directionalLight.position.copy(camera.position);
                directionalLight.target = new THREE.Object3D(); // Crea un target vuoto
                scene.add(directionalLight.target); // Aggiungi il target alla scena
                scene.add(directionalLight); // Aggiungi la luce alla scena

                const planetGroup = new THREE.Group();
                planetGroup.rotation.z = THREE.MathUtils.degToRad(data.axialTilt);
                scene.add(planetGroup);
                
                const displayRadius = 1.2;
                camera.position.set(0, 0, displayRadius * 3); // Posizione iniziale della telecamera

                if (id === 'earth') {
                    createEarthLayers(planetGroup, displayRadius);
                    loadContinents(planetGroup, displayRadius);
                    createAtmosphereLayers(planetGroup, displayRadius);
                } else {
                    const material = new THREE.MeshStandardMaterial({ map: textureLoader.load(data.textureUrl) });
                    const mesh = new THREE.Mesh(new THREE.SphereGeometry(displayRadius, 64, 64), material);
                    planetGroup.add(mesh);
                    
                    if (data.ringTextureUrl) {
                        const ringMaterial = new THREE.MeshBasicMaterial({
                            map: textureLoader.load(data.ringTextureUrl),
                            side: THREE.DoubleSide,
                            transparent: true,
                            opacity: 0.7
                        });
                        const ringGeometry = new THREE.RingGeometry(displayRadius * 1.3, displayRadius * 2, 64);
                        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
                        ring.rotation.x = -Math.PI / 2;
                        planetGroup.add(ring);
                    }
                }

                const controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
                controls.enablePan = false;
                controls.minDistance = displayRadius * 1.5;
                controls.maxDistance = displayRadius * 5;
                
                // Aggiorna la direzione della luce quando la camera si muove
                controls.addEventListener('change', () => {
                    directionalLight.position.copy(camera.position);
                });

                new ResizeObserver(() => {
                    if (container.clientWidth > 0 && container.clientHeight > 0) {
                        camera.aspect = container.clientWidth / container.clientHeight;
                        camera.updateProjectionMatrix();
                        renderer.setSize(container.clientWidth, container.clientHeight);
                    }
                }).observe(container);

                scenesToAnimate.push({ renderer, scene, camera, controls, planetGroup, data });
            }
            
            // --- Funzioni per creare il modello dettagliato della Terra ---
            function createEarthLayers(earthGroup, baseRadius) {
                const oceanMaterial = new THREE.MeshStandardMaterial({ color: 0x4B83B8, roughness: 0.5 });
                const ocean = new THREE.Mesh(new THREE.SphereGeometry(baseRadius, 64, 64), oceanMaterial);
                earthGroup.add(ocean);
            }

            function createAtmosphereLayers(earthGroup, baseRadius) {
                const material = new THREE.MeshBasicMaterial({ color: 0xADD8E6, side: THREE.BackSide, transparent: true, opacity: 0.5 });
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(baseRadius * 1.04, 64, 64), material);
                earthGroup.add(mesh);
            }

            function loadContinents(earthGroup, baseRadius) {
                fetch("https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json")
                    .then(res => res.json())
                    .then(data => data.features.forEach(feature => {
                        createMeshesFromFeature(feature, continentMaterial, baseRadius).forEach(mesh => earthGroup.add(mesh));
                    }));
            }

            function createMeshesFromFeature(feature, material, baseRadius) {
                const meshes = [];
                const shapes = [];
                if (feature.geometry.type === 'Polygon') {
                    shapes.push(...createShapesFromCoords(feature.geometry.coordinates));
                } else if (feature.geometry.type === 'MultiPolygon') {
                    feature.geometry.coordinates.forEach(coords => shapes.push(...createShapesFromCoords(coords)));
                }
                shapes.forEach(shape => {
                    const geometry = new THREE.ExtrudeGeometry(shape, { depth: baseRadius * 0.02, bevelEnabled: false });
                    const mesh = new THREE.Mesh(geometry, material);
                    const pos = geometry.attributes.position;
                    for (let i = 0; i < pos.count; i++) {
                        const r = baseRadius + pos.getZ(i);
                        const lat = (90 - pos.getY(i)) * Math.PI / 180;
                        const lon = (pos.getX(i) + 180) * Math.PI / 180;
                        pos.setXYZ(i, -r * Math.sin(lat) * Math.cos(lon), r * Math.cos(lat), r * Math.sin(lat) * Math.sin(lon));
                    }
                    mesh.geometry.computeVertexNormals();
                    meshes.push(mesh);
                });
                return meshes;
            }

            function createShapesFromCoords(coords) {
                return coords.map(ring => {
                    const shape = new THREE.Shape();
                    if (ring.length > 0) {
                        shape.moveTo(ring[0][0], ring[0][1]);
                        ring.slice(1).forEach(p => shape.lineTo(p[0], p[1]));
                    }
                    return shape;
                });
            }

            // --- Inizializzazione ---
            for (const id in PLANET_DATA) {
                const container = document.getElementById(`${id}-canvas`);
                if (container) createPlanetScene(container, id);
            }

            // --- Gestione Pulsante Reset ---
            document.getElementById('reset-view-btn').addEventListener('click', () => {
                scenesToAnimate.forEach(s => {
                    s.controls.reset();
                });
            });

            // --- Loop di Animazione ---
            function animate() {
                requestAnimationFrame(animate);
                scenesToAnimate.forEach(s => {
                    if (s.data.rotationDays !== 0) {
                        s.planetGroup.rotation.y += (1 / s.data.rotationDays) * 0.05;
                    }
                    s.controls.update(); // Aggiorna i controlli (e indirettamente la posizione della luce)
                    s.renderer.render(s.scene, s.camera);
                });
            }

            animate();
        });
    </script>
</body>
</html>
