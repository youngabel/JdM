<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Sistema Solare Interno v1.0</title>
    <style>
        html, body {
            height: 100%;
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: monospace;
        }
        #map-container {
            width: 100%;
            height: 100%;
            cursor: grab;
            position: absolute;
            top: 0;
            left: 0;
        }
        #map-container:grabbing {
            cursor: grabbing;
        }
        /* Stile per le etichette dei pianeti */
        .label {
            color: #fff;
            font-size: 14px;
            text-shadow: -1px 1px 1px #000;
            pointer-events: none;
        }
        .ui-controls {
            position: absolute;
            top: 20px;
            padding: 10px 15px;
            background-color: rgba(0, 0, 0, 0.7);
            color: #fff;
            font-size: 14px;
            border-radius: 5px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10;
        }
        .control-row {
            display: flex;
            align-items: center;
            gap: 10px;
            justify-content: space-between;
        }
        #main-controls { left: 20px; }
        #simulation-controls { right: 20px; }
        .ui-controls input[type="range"] { cursor: pointer; width: 120px; }
        .ui-controls input[type="color"] { width: 40px; height: 25px; padding: 0; border: 1px solid #999; background: transparent; }
        .ui-controls input[type="checkbox"] { width: 20px; height: 20px; cursor: pointer;}
    </style>
</head>
<body>
    <div id="map-container"></div>
    
    <div id="main-controls" class="ui-controls">
        <div class="control-row">
            <label for="color-picker">Continenti:</label>
            <input type="color" id="color-picker" value="#cccccc">
        </div>
        <div class="control-row">
            <label for="orbit-toggle">Mostra Orbite:</label>
            <input type="checkbox" id="orbit-toggle" checked>
        </div>
    </div>
    
    <div id="simulation-controls" class="ui-controls">
        <div class="control-row">
             <label for="speed-slider">Velocità:</label>
             <input type="range" id="speed-slider" min="0" max="5000" value="500">
        </div>
        <div class="control-row">
            <label for="brightness-slider">Luminosità:</label>
            <input type="range" id="brightness-slider" min="0" max="5" value="2.5" step="0.1">
        </div>
    </div>

    <script type="module">
        import * as THREE from 'https://cdn.skypack.dev/three@0.128.0';
        import { OrbitControls } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/controls/OrbitControls.js';
        import { CSS2DRenderer, CSS2DObject } from 'https://cdn.skypack.dev/three@0.128.0/examples/jsm/renderers/CSS2DRenderer.js';

        document.addEventListener('DOMContentLoaded', () => {
            
            const PLANET_DATA = {
                mercury: { name: 'Mercurio', au: 0.39, yearDays: 88, rotationDays: 58.6, radiusScale: 0.38, color: 0x9e9e9e },
                venus:   { name: 'Venere', au: 0.72, yearDays: 225, rotationDays: -243, radiusScale: 0.95, color: 0xf8e29f },
                earth:   { name: 'Terra', au: 1.0, yearDays: 365.25, rotationDays: 1, radiusScale: 1.0, color: null },
                mars:    { name: 'Marte', au: 1.52, yearDays: 687, rotationDays: 1.03, radiusScale: 0.53, color: 0xd86c37 },
                moon:    { name: 'Luna', au: 0.00257, yearDays: 27.3, rotationDays: 27.3, radiusScale: 0.27, color: 0xaaaaaa }
            };

            let scene, camera, renderer, labelRenderer, controls, sun, sunLight;
            let continentMaterial;
            let rotationSpeed = 0.01;
            
            const celestialBodies = [];
            const container = document.getElementById('map-container');
            const textureLoader = new THREE.TextureLoader();
            
            const rockNormalMap = textureLoader.load('https://threejs.org/examples/textures/planets/plutomap1k.jpg');

            const THETA_START = Math.PI * 1.25;
            const THETA_LENGTH = Math.PI * 1.5;

            function scaleLog(au) {
                return 15 * Math.log(au + 1) + 5;
            }

            function init() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(45, container.clientWidth / container.clientHeight, 0.1, 5000);
                const earthScaledPos = scaleLog(PLANET_DATA.earth.au);
                camera.position.set(earthScaledPos + 15, 15, 15);

                renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                container.appendChild(renderer.domElement);

                labelRenderer = new CSS2DRenderer();
                labelRenderer.setSize(container.clientWidth, container.clientHeight);
                labelRenderer.domElement.style.position = 'absolute';
                labelRenderer.domElement.style.top = '0px';
                labelRenderer.domElement.style.pointerEvents = 'none';
                container.appendChild(labelRenderer.domElement);

                scene.add(new THREE.AmbientLight(0x404040, 0.2));
                continentMaterial = new THREE.MeshLambertMaterial({ color: 0xcccccc, side: THREE.DoubleSide });

                createSun();
                
                const mercury = createPlanet('mercury');
                const venus = createPlanet('venus');
                const earth = createPlanet('earth');
                const mars = createPlanet('mars');
                const moon = createMoon(earth.body); // Passa il gruppo-corpo della terra
                celestialBodies.push(mercury, venus, earth, mars, moon);
                
                setupControls();
                setupEventListeners();
                animate();
            }

            function createSun() {
                sun = new THREE.Group();
                scene.add(sun);
                sunLight = new THREE.PointLight(0xffffff, 2.5, 0, 2);
                sunLight.castShadow = true;
                sunLight.shadow.mapSize.width = 2048;
                sunLight.shadow.mapSize.height = 2048;
                sun.add(sunLight);
                const sunMesh = new THREE.Mesh( new THREE.SphereGeometry(2, 32, 32), new THREE.MeshBasicMaterial({ color: 0xffffee }) );
                sun.add(sunMesh);
            }

            function createPlanet(id) {
                const data = PLANET_DATA[id];
                const pivot = new THREE.Group();
                scene.add(pivot);
                const body = new THREE.Group();
                body.position.x = scaleLog(data.au);
                pivot.add(body);

                if (data.color) {
                    const material = new THREE.MeshStandardMaterial({ color: data.color, normalMap: rockNormalMap });
                    const mesh = new THREE.Mesh(new THREE.SphereGeometry(data.radiusScale, 32, 32), material);
                    mesh.castShadow = true;
                    mesh.receiveShadow = true;
                    body.add(mesh);
                } else if (id === 'earth') {
                    createEarthLayers(body);
                    loadContinents(body);
                    createAtmosphereLayers(body);
                }

                const label = createLabel(data.name);
                body.add(label);
                const orbitTrail = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0x0077ff }));
                scene.add(orbitTrail);

                return {
                    id, pivot, body, trail: orbitTrail, trailPoints: [],
                    revolutionSpeed: (PLANET_DATA.earth.yearDays / data.yearDays),
                    rotationSpeed: (PLANET_DATA.earth.yearDays / data.rotationDays)
                };
            }

            function createMoon(earthBodyGroup) {
                const data = PLANET_DATA.moon;
                const pivot = new THREE.Group();
                earthBodyGroup.add(pivot); // CORREZIONE: La luna orbita la Terra, non il sole

                const body = new THREE.Group();
                body.position.x = scaleLog(data.au) + 2.5; // Distanza dalla Terra
                pivot.add(body);
                
                const material = new THREE.MeshStandardMaterial({ color: data.color, normalMap: rockNormalMap });
                const mesh = new THREE.Mesh(new THREE.SphereGeometry(data.radiusScale, 32, 32), material);
                mesh.castShadow = true;
                mesh.receiveShadow = true;
                body.add(mesh);

                const label = createLabel(data.name);
                body.add(label);
                const orbitTrail = new THREE.Line(new THREE.BufferGeometry(), new THREE.LineBasicMaterial({ color: 0xdddddd }));
                scene.add(orbitTrail);

                return {
                    id: 'moon', pivot, body, trail: orbitTrail, trailPoints: [],
                    revolutionSpeed: (PLANET_DATA.earth.yearDays / data.yearDays),
                    rotationSpeed: 0 // Blocco mareale
                };
            }

            function createLabel(name) {
                const div = document.createElement('div');
                div.className = 'label';
                div.textContent = name;
                return new CSS2DObject(div);
            }
            
            function createEarthLayers(earthGroup){const e=[{radius:.19,color:16777113},{radius:.54,color:16747520},{radius:.89,color:14491136},{radius:.99,color:9127191},{radius:1,color:6635777}];e.reverse().forEach(o=>{const t=new THREE.SphereGeometry(o.radius,64,64,THETA_START,THETA_LENGTH),r=new THREE.MeshStandardMaterial({color:o.color,side:THREE.DoubleSide}),n=new THREE.Mesh(t,r);n.castShadow=!0,n.receiveShadow=!0,earthGroup.add(n)})}
            function createAtmosphereLayers(earthGroup){const e=[{radius:1.1,color:8900331,opacity:.5},{radius:1.2,color:4620980,opacity:.4}];e.forEach(o=>{const t=new THREE.SphereGeometry(o.radius,64,64,THETA_START,THETA_LENGTH),r=new THREE.MeshBasicMaterial({color:o.color,side:THREE.DoubleSide,transparent:!0,opacity:o.opacity});earthGroup.add(new THREE.Mesh(t,r))})}
            function loadContinents(earthGroup){fetch("https://raw.githubusercontent.com/johan/world.geo.json/master/countries.geo.json").then(e=>e.json()).then(e=>e.features.forEach(o=>createMeshesFromFeature(o,continentMaterial).forEach(t=>earthGroup.add(t))))}
            function createMeshesFromFeature(e,o){const t=[];if(!e.geometry)return t;const r=[];return"Polygon"===e.geometry.type?r.push(...createShapesFromCoords(e.geometry.coordinates)):"MultiPolygon"===e.geometry.type&&e.geometry.coordinates.forEach(n=>r.push(...createShapesFromCoords(n))),r.forEach(n=>{const a=new THREE.ExtrudeGeometry(n,{depth:.01,bevelEnabled:!1}),i=new THREE.Mesh(a,o);i.receiveShadow=!0;const d=a.attributes.position;for(let s=0;s<d.count;s++){const c=d.getX(s),l=d.getY(s),p=1.005+d.getZ(s),u=(90-l)*Math.PI/180,m=(c+180)*Math.PI/180,h=-p*Math.sin(u)*Math.cos(m),E=p*Math.cos(u),w=p*Math.sin(u)*Math.sin(m);d.setXYZ(s,h,E,w)}i.geometry.computeVertexNormals(),t.push(i)}),t}
            function createShapesFromCoords(e){return e.map(o=>{const t=new THREE.Shape;return o.length>0&&o[0].length>1&&(t.moveTo(o[0][0],o[0][1]),o.slice(1).forEach(r=>{r.length>1&&t.lineTo(r[0],r[1])})),t})}
            
            function setupControls() {
                controls = new OrbitControls(camera, renderer.domElement);
                controls.enableDamping = true;
            }
            
            function setupEventListeners() {
                window.addEventListener('resize', onWindowResize);
                document.getElementById('color-picker').addEventListener('input', e => continentMaterial.color.set(e.target.value));
                document.getElementById('speed-slider').addEventListener('input', e => rotationSpeed = parseFloat(e.target.value) / 50000);
                document.getElementById('brightness-slider').addEventListener('input', e => sunLight.intensity = parseFloat(e.target.value));
                document.getElementById('orbit-toggle').addEventListener('change', e => celestialBodies.forEach(b => {
                    b.trail.visible = e.target.checked;
                    if(!e.target.checked) {
                        b.trailPoints.length = 0;
                        b.trail.geometry.setFromPoints([]);
                    }
                }));
            }

            function onWindowResize() {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
                labelRenderer.setSize(window.innerWidth, window.innerHeight);
            }

            function animate() {
                requestAnimationFrame(animate);
                
                const revolutionBaseSpeed = rotationSpeed / PLANET_DATA.earth.yearDays;
                
                celestialBodies.forEach(body => {
                    body.pivot.rotation.y += revolutionBaseSpeed * body.revolutionSpeed;
                    if (body.rotationSpeed !== 0) {
                        body.body.rotation.y += revolutionBaseSpeed * body.rotationSpeed;
                    }
                    if (body.trail.visible) {
                        const currentPosition = new THREE.Vector3();
                        body.body.getWorldPosition(currentPosition);
                        body.trailPoints.push(currentPosition.clone());
                        body.trail.geometry.setFromPoints(body.trailPoints);
                    }
                });

                const earthWorldPosition = new THREE.Vector3();
                celestialBodies.find(b => b.id === 'earth').body.getWorldPosition(earthWorldPosition);
                controls.target.copy(earthWorldPosition);

                controls.update();
                renderer.render(scene, camera);
                labelRenderer.render(scene, camera);
            }
            
            init();
        });
    </script>
</body>
</html>
