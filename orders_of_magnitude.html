<!DOCTYPE html>
<html lang="it">
<head>
    <title>Ordini di Grandezza - Three.js</title>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            font-family: monospace;
            background-color: #000;
            color: #fff;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }
        canvas {
            display: block;
        }
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 8px;
            border: 1px solid #333;
        }
        .slider-group {
            margin-bottom: 8px;
            display: flex;
            align-items: center;
        }
        .slider-group label {
            min-width: 140px;
            display: inline-block;
        }
        .slider-group input[type="range"] {
            width: 180px;
            margin-right: 10px;
        }
        .slider-group span {
            min-width: 80px;
            text-align: right;
            font-weight: bold;
            color: #0f0; /* Colore verde per i valori numerici */
        }
        #current-cubes-value {
            color: #ffcc00; /* Colore giallo per il totale cubi */
        }
        #instructions {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 8px;
            border-radius: 5px;
            font-size: 0.8em;
            color: #aaa;
        }
    </style>
</head>

<body>
    <div id="ui">
        <div class="slider-group">
            <label for="speed">Velocità:</label>
            <input type="range" id="speed" min="1" max="100" value="10" step="1">
            <span id="speed-value">10.0 m/s</span>
        </div>
        <div class="slider-group">
            <label for="baseN">Base N:</label>
            <input type="range" id="baseN" min="2" max="15" value="5" step="1">
            <span id="baseN-value">5</span>
        </div>
        <div class="slider-group">
            <label for="orderM">Ordine M (N^M):</label>
            <input type="range" id="orderM" min="0" max="10" value="3" step="1">
            <span id="orderM-value">3</span>
        </div>
        <div class="slider-group">
            <label for="cubeSize">Lato Cubo (S):</label>
            <input type="range" id="cubeSize" min="0.1" max="5" value="1" step="0.1">
            <span id="cubeSize-value">1.0 m</span>
        </div>
        <div class="slider-group">
            <label>Cubi Totali (appross.):</label>
            <span id="current-cubes-value">0</span>
        </div>
    </div>

    <div id="instructions">
        Frecce Direzionali: Muovi avanti/indietro, ruota sinistra/destra.
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.skypack.dev/three@0.136.0"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';

        // --- Variabili Globali ---
        let scene, camera, renderer, player, clock;
        let keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };
        let speed = 10;
        let sceneObjects = new THREE.Group(); // Gruppo per contenere tutti i cubi e le etichette

        // Elementi UI
        const sliderSpeed = document.getElementById('speed');
        const valueSpeed = document.getElementById('speed-value');
        const sliderN = document.getElementById('baseN');
        const valueN = document.getElementById('baseN-value');
        const sliderM = document.getElementById('orderM');
        const valueM = document.getElementById('orderM-value');
        const sliderSize = document.getElementById('cubeSize');
        const valueSize = document.getElementById('cubeSize-value');
        const currentCubesValue = document.getElementById('current-cubes-value');

        // Materiale e Geometria condivisi
        const cubeMaterial = new THREE.MeshBasicMaterial({
            color: 0x00ff00,
            wireframe: true,
            transparent: true,
            opacity: 0.8
        }); // Opacità per vedere attraverso
        
        // --- Funzione Principale di Inizializzazione ---
        function init() {
            // 1. Scena e Orologio
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x050505);
            scene.fog = new THREE.Fog(0x050505, 100, 1500); // Nebbia per performance e atmosfera
            clock = new THREE.Clock();

            // 2. Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            document.body.appendChild(renderer.domElement);

            // 3. Camera e Player
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 10000);
            
            player = new THREE.Group();
            player.position.set(0, 1.7, 0); // Altezza uomo (1.7m)
            player.add(camera); // Attacca la camera al player
            scene.add(player);

            // 4. Luci
            const ambientLight = new THREE.AmbientLight(0x404040, 2);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
            directionalLight.position.set(5, 10, 7.5);
            scene.add(directionalLight);

            // 5. Piano (y=0)
            const planeGeometry = new THREE.PlaneGeometry(10000, 10000, 200, 200);
            const planeMaterial = new THREE.MeshStandardMaterial({
                color: 0x333333,
                wireframe: true,
                fog: false
            });
            const plane = new THREE.Mesh(planeGeometry, planeMaterial);
            plane.rotation.x = -Math.PI / 2;
            plane.position.y = 0;
            scene.add(plane);
            
            // 6. Aggiungi il gruppo per gli oggetti
            scene.add(sceneObjects);

            // 7. Event Listener
            document.addEventListener('keydown', (e) => { keys[e.key] = true; });
            document.addEventListener('keyup', (e) => { keys[e.key] = false; });
            window.addEventListener('resize', onWindowResize);

            // Listener per gli slider
            sliderSpeed.addEventListener('input', (e) => {
                speed = parseFloat(e.target.value);
                valueSpeed.textContent = `${speed.toFixed(1)} m/s`;
            });
            
            sliderN.addEventListener('input', (e) => {
                valueN.textContent = e.target.value;
                buildWorld(); // Ricostruisce il mondo al cambio di N
            });
            
            sliderM.addEventListener('input', (e) => {
                valueM.textContent = e.target.value;
                buildWorld(); // Ricostruisce il mondo al cambio di M
            });

            sliderSize.addEventListener('input', (e) => {
                valueSize.textContent = `${parseFloat(e.target.value).toFixed(1)} m`;
                buildWorld(); // Ricostruisce il mondo al cambio di S
            });

            // 8. Costruzione iniziale e avvio loop
            buildWorld();
            animate();
        }

        // --- Funzione per (Ri)Costruire il Mondo ---
        function buildWorld() {
            // Rimuovi i vecchi oggetti
            scene.remove(sceneObjects);
            sceneObjects = new THREE.Group();
            scene.add(sceneObjects);

            // Ottieni valori correnti dagli slider
            const N = parseInt(sliderN.value);
            const M = parseInt(sliderM.value);
            const S = parseFloat(sliderSize.value); // Lato del cubo
            const gap = S * 1.5; // Spaziatura tra i cubi
            
            let zCursor = -50; // Posizione Z iniziale per il layout delle regioni
            let totalCubesCount = 0;

            const cubeGeom = new THREE.BoxGeometry(S, S, S);
            const dummy = new THREE.Object3D(); // Oggetto 'dummy' per impostare le matrici

            // Limite istanze per Three.js e GPU
            const maxInstancedCubes = 1000000; // Un milione di cubi è un buon limite per un browser
            
            // Ciclo per generare gli ordini N^m (m da 0 a M)
            for (let m = 0; m <= M; m++) {
                const numCubesInThisOrder = Math.pow(N, m);
                
                let actualCubesGenerated = numCubesInThisOrder;
                let labelText = `N^${m} = ${numCubesInThisOrder.toLocaleString('it-IT')}`;

                if (numCubesInThisOrder > maxInstancedCubes && m > 0) { // Applica limite solo se m > 0 e se si supera
                     actualCubesGenerated = maxInstancedCubes;
                     labelText += ` (limitato a ${maxInstancedCubes.toLocaleString('it-IT')})`;
                }

                // Posizione base per questa regione sull'asse Z
                const regionZ = zCursor;

                // --- Posiziona l'etichetta per questo ordine ---
                // Le etichette sono posizionate lateralmente, rispetto al primo cubo del livello
                const labelXOffset = - (S + gap * 2); // Spostato a sinistra del primo cubo
                const labelYPosition = S * 2; // Sopra il piano
                
                const label = createLabel(labelText, '#ffcc00'); // Colore giallo per le etichette
                label.position.set(labelXOffset, labelYPosition, regionZ);
                sceneObjects.add(label);

                if (numCubesInThisOrder === 0) {
                    // Nessun cubo da disegnare (solo per N=0, non dovrebbe accadere con N min=2)
                } else if (numCubesInThisOrder === 1 && m === 0) {
                    // Caso speciale N^0 = 1
                    const singleCube = new THREE.Mesh(cubeGeom, cubeMaterial);
                    singleCube.position.set(0, S / 2, regionZ);
                    sceneObjects.add(singleCube);
                    totalCubesCount += 1;
                    zCursor -= 50 + gap; // Spazio per la prossima regione
                } else {
                    // Generazione per N^1, N^2, N^3, ... N^M
                    const instancedMesh = new THREE.InstancedMesh(cubeGeom, cubeMaterial, actualCubesGenerated);
                    let k = 0; // Contatore per le istanze effettive

                    const positions = [];
                    const generatePositions = (depth, currentPos) => {
                        if (depth === m) {
                            // Una combinazione di dimensioni è completa
                            positions.push([...currentPos]);
                            return;
                        }
                        for (let i = 0; i < N; i++) {
                            if (k >= actualCubesGenerated) return; // Se abbiamo già raggiunto il limite di istanze
                            generatePositions(depth + 1, [...currentPos, i]);
                        }
                    };

                    // Genera le posizioni in un array per poi usarle con InstancedMesh
                    generatePositions(0, []);

                    // Calcola offset per centrare il blocco (necessario per N^m dimensioni)
                    const dimensionSize = (N - 1) * gap; // Dimensione totale di N cubi in una dimensione
                    const centerOffset = dimensionSize / 2;

                    // Itera sulle posizioni generate e imposta le matrici delle istanze
                    for (let i = 0; i < Math.min(positions.length, actualCubesGenerated); i++) {
                        if (k >= actualCubesGenerated) break;

                        const coords = positions[i];
                        let x = 0, y = S / 2, z = regionZ;

                        // Per ogni dimensione (da 0 a m-1)
                        if (m >= 1) x = coords[0] * gap - centerOffset; // Dimenisone 1 (X)
                        if (m >= 2) z = regionZ - (coords[1] * gap - centerOffset); // Dimensione 2 (Z, invertito per andare in profondità)
                        if (m >= 3) y = coords[2] * gap + S / 2; // Dimensione 3 (Y, altezza)
                        
                        // Per m > 3, stiviamo lungo l'asse X o Z per creare "bins"
                        if (m >= 4) {
                            const binWidth = N * gap + gap * 2; // Larghezza di un "bin" N^(m-1)
                            const binXOffset = (N - 1) * binWidth / 2; // Per centrare i bin sull'asse X
                            x = (coords[0] * binWidth - binXOffset) + (coords[1] * gap - centerOffset);
                            z = regionZ - (coords[2] * gap - centerOffset);
                            y = coords[3] * gap + S / 2;
                            if (m >= 5) { // Un'altra dimensione, la mettiamo lungo Z
                                const binDepth = N * gap + gap * 2;
                                const binZOffset = (N - 1) * binDepth / 2;
                                z = (regionZ - (coords[1] * binDepth - binZOffset)) - (coords[2] * gap - centerOffset);
                                x = (coords[0] * binWidth - binXOffset) + (coords[3] * gap - centerOffset);
                                y = coords[4] * gap + S / 2;
                            }
                            // Potresti continuare qui per m=6, m=7 ecc. decidendo come disporli nello spazio 3D
                        }


                        dummy.position.set(x, y, z);
                        dummy.updateMatrix();
                        instancedMesh.setMatrixAt(k++, dummy.matrix);
                    }
                    instancedMesh.count = k;
                    instancedMesh.instanceMatrix.needsUpdate = true;
                    sceneObjects.add(instancedMesh);
                    totalCubesCount += k;

                    // Avanza il cursore Z per la prossima regione, basandosi sulla dimensione massima del blocco attuale
                    const maxDim = (m > 0) ? (N * gap) : gap; // La dimensione maggiore della regione
                    zCursor -= maxDim + 50 + gap;
                }
            }
            
            // Aggiorna il contatore cubi nell'UI
            currentCubesValue.textContent = totalCubesCount.toLocaleString('it-IT');
        }


        // --- Funzione Helper per creare Etichette 3D ---
        function createLabel(text, color = '#ffffff') { // Aggiunto parametro colore
            const canvas = document.createElement('canvas');
            const context = canvas.getContext('2d');
            const fontSize = 48;
            context.font = `Bold ${fontSize}px Monospace`;
            const textWidth = context.measureText(text).width;

            canvas.width = textWidth + 40; // Padding aumentato
            canvas.height = fontSize + 20;
            
            context.font = `Bold ${fontSize}px Monospace`;
            context.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Sfondo semi-trasparente per leggibilità
            context.fillRect(0, 0, canvas.width, canvas.height);
            context.fillStyle = color; // Usa il colore passato
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            context.fillText(text, canvas.width / 2, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            const spriteMaterial = new THREE.SpriteMaterial({ map: texture, transparent: true });
            const sprite = new THREE.Sprite(spriteMaterial);
            
            sprite.scale.set(canvas.width * 0.05, canvas.height * 0.05, 1.0);
            return sprite;
        }

        // --- Loop di Animazione ---
        function animate() {
            requestAnimationFrame(animate);
            const delta = clock.getDelta(); // Tempo trascorso dall'ultimo frame (in secondi)

            updateMovement(delta);

            renderer.render(scene, camera);
        }

        // --- Aggiornamento Movimento Player ---
        function updateMovement(delta) {
            const moveDistance = speed * delta; // Distanza = velocità * tempo
            const rotateAngle = (Math.PI / 2) * delta; // 90 gradi al secondo

            if (keys.ArrowUp) {
                player.translateZ(-moveDistance); // Muovi in avanti (lungo la Z locale)
            }
            if (keys.ArrowDown) {
                player.translateZ(moveDistance); // Muovi indietro
            }
            if (keys.ArrowLeft) {
                player.rotateY(rotateAngle); // Ruota a sinistra (attorno alla Y locale)
            }
            if (keys.ArrowRight) {
                player.rotateY(-rotateAngle); // Ruota a destra
            }
        }

        // --- Gestione Resize Finestra ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        // --- Avvio ---
        init();

    </script>
</body>
</html>
