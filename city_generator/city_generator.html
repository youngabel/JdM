<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore Procedurale di Città 3D</title>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: #111820; color: #fff; overflow: hidden; }
        #scene-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-panel { position: fixed; top: 10px; left: 10px; width: 320px; max-height: calc(100% - 20px); background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); border-radius: 8px; padding: 15px; overflow-y: auto; color: #eee; border: 1px solid #444; }
        h2, h3 { margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 14px; }
        .control-group input[type="range"] { width: 100%; }
        .control-group span { float: right; font-weight: bold; }
        button { background-color: #007bff; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; width: 100%; margin-top: 10px; font-weight: bold; }
        button:hover { background-color: #0056b3; }
        .export-buttons { display: flex; gap: 5px; }
        #preview-container { display: grid; grid-template-columns: repeat(auto-fill, minmax(80px, 1fr)); gap: 10px; margin-top: 15px; }
        .preview-box { width: 100%; aspect-ratio: 1; background: #222; border-radius: 4px; border: 1px solid #555; }
        .preview-box canvas { width: 100% !important; height: 100% !important; }
    </style>
</head>
<body>

    <div id="scene-container"></div>

    <div id="ui-panel">
        <h2>Parametri Città</h2>
        <div class="control-group">
            <label>Seme Casuale: <span id="seed-value">1</span></label>
            <input type="range" id="seed" min="1" max="10000" value="1">
        </div>
        <div class="control-group">
            <label>Dimensione Città (X): <span id="cityWidth-value">500</span></label>
            <input type="range" id="cityWidth" min="100" max="2000" value="500" step="10">
        </div>
        <div class="control-group">
            <label>Dimensione Città (Z): <span id="cityDepth-value">500</span></label>
            <input type="range" id="cityDepth" min="100" max="2000" value="500" step="10">
        </div>
        <div class="control-group">
            <label>Numero Isolati (X): <span id="blocksX-value">5</span></label>
            <input type="range" id="blocksX" min="2" max="20" value="5">
        </div>
        <div class="control-group">
            <label>Numero Isolati (Z): <span id="blocksZ-value">5</span></label>
            <input type="range" id="blocksZ" min="2" max="20" value="5">
        </div>
         <div class="control-group">
            <label>Larghezza Strade: <span id="streetWidth-value">10</span></label>
            <input type="range" id="streetWidth" min="2" max="50" value="10">
        </div>

        <h3>Edifici</h3>
        <div class="control-group">
            <label>Densità Finestre: <span id="windowDensity-value">0.6</span></label>
            <input type="range" id="windowDensity" min="0.1" max="1" value="0.6" step="0.05">
        </div>
        <div class="control-group">
            <label>Altezza Grattacieli: <span id="skyscraperHeight-value">300</span></label>
            <input type="range" id="skyscraperHeight" min="100" max="500" value="300">
        </div>
         <div class="control-group">
            <label>Altezza Palazzi: <span id="palaceHeight-value">120</span></label>
            <input type="range" id="palaceHeight" min="50" max="200" value="120">
        </div>
        <div class="control-group">
            <label>Altezza Condomini: <span id="condoHeight-value">60</span></label>
            <input type="range" id="condoHeight" min="20" max="100" value="60">
        </div>
        <div class="control-group">
            <label>Altezza Case: <span id="houseHeight-value">20</span></label>
            <input type="range" id="houseHeight" min="5" max="40" value="20">
        </div>
        <div class="control-group">
            <label>Altezza Industrie: <span id="industryHeight-value">40</span></label>
            <input type="range" id="industryHeight" min="10" max="80" value="40">
        </div>
        
        <button id="generate-btn">Genera Nuova Città</button>
        
        <h3>Esporta</h3>
        <div class="export-buttons">
            <button id="export-png-btn">PNG</button>
            <button id="export-hd-png-btn">PNG HD</button>
            <button id="export-pdf-btn">PDF</button>
            <button id="export-svg-btn">SVG</button>
        </div>

        <h3>Anteprime Modelli</h3>
        <div id="preview-container">
            <div id="preview-skyscrapers" class="preview-box" title="Grattacieli"></div>
            <div id="preview-palaces" class="preview-box" title="Palazzi"></div>
            <div id="preview-condos" class="preview-box" title="Condomini"></div>
            <div id="preview-houses" class="preview-box" title="Case"></div>
            <div id="preview-industries" class="preview-box" title="Industrie"></div>
        </div>
    </div>

    <script type="importmap">
    {
        "imports": {
            "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
            "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/",
            "jspdf": "https://unpkg.com/jspdf@2.5.1/dist/jspdf.es.min.js"
        }
    }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { SVGRenderer } from 'three/addons/renderers/SVGRenderer.js';
        import { jsPDF } from "jspdf";

        // --- VARIABILI GLOBALI ---
        let scene, camera, renderer, controls, cityGroup;
        const SCENE_BG_COLOR = 0x111820;

        const buildingTypes = {
            SKYSCRAPER: 'skyscraper', PALACE: 'palace', CONDO: 'condo', HOUSE: 'house', INDUSTRY: 'industry'
        };
        const previewScenes = {};

        // --- INIZIALIZZAZIONE ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(SCENE_BG_COLOR);
            scene.fog = new THREE.Fog(SCENE_BG_COLOR, 500, 2200);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 5000);
            camera.position.set(200, 300, 400);

            const container = document.getElementById('scene-container');
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const ambientLight = new THREE.AmbientLight(0xaaaaee, 0.7);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.5);
            dirLight.position.set(300, 400, 250);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 2048;
            dirLight.shadow.mapSize.height = 2048;
            dirLight.shadow.camera.left = -1000;
            dirLight.shadow.camera.right = 1000;
            dirLight.shadow.camera.top = 1000;
            dirLight.shadow.camera.bottom = -1000;
            scene.add(dirLight);

            cityGroup = new THREE.Group();
            scene.add(cityGroup);

            setupUI();
            setupPreviews();
            generateCity();
            animate();

            window.addEventListener('resize', onWindowResize);
        }

        // --- GESTIONE UI E PARAMETRI ---
        function setupUI() {
            const sliders = document.querySelectorAll('input[type="range"]');
            sliders.forEach(slider => {
                document.getElementById(`${slider.id}-value`).textContent = slider.value;
                slider.addEventListener('input', (e) => {
                    document.getElementById(`${slider.id}-value`).textContent = e.target.value;
                    if (slider.id !== 'seed') generateCity();
                });
                slider.addEventListener('change', () => {
                    if (slider.id === 'seed') generateCity();
                });
            });

            document.getElementById('generate-btn').addEventListener('click', () => {
                const seedInput = document.getElementById('seed');
                seedInput.value = Math.floor(Math.random() * 10000) + 1;
                document.getElementById('seed-value').textContent = seedInput.value;
                generateCity();
            });

            document.getElementById('export-png-btn').addEventListener('click', () => exportImage(1));
            document.getElementById('export-hd-png-btn').addEventListener('click', () => exportImage(3));
            document.getElementById('export-pdf-btn').addEventListener('click', exportPDF);
            document.getElementById('export-svg-btn').addEventListener('click', exportSVG);
        }

        function getParams() {
            return {
                seed: parseInt(document.getElementById('seed').value),
                cityWidth: parseInt(document.getElementById('cityWidth').value),
                cityDepth: parseInt(document.getElementById('cityDepth').value),
                blocksX: parseInt(document.getElementById('blocksX').value),
                blocksZ: parseInt(document.getElementById('blocksZ').value),
                streetWidth: parseInt(document.getElementById('streetWidth').value),
                windowDensity: parseFloat(document.getElementById('windowDensity').value),
                heights: {
                    [buildingTypes.SKYSCRAPER]: parseInt(document.getElementById('skyscraperHeight').value),
                    [buildingTypes.PALACE]: parseInt(document.getElementById('palaceHeight').value),
                    [buildingTypes.CONDO]: parseInt(document.getElementById('condoHeight').value),
                    [buildingTypes.HOUSE]: parseInt(document.getElementById('houseHeight').value),
                    [buildingTypes.INDUSTRY]: parseInt(document.getElementById('industryHeight').value)
                }
            };
        }

        // --- LOGICA DI GENERAZIONE DELLA CITTÀ ---
        function generateCity() {
            while (cityGroup.children.length > 0) {
                const obj = cityGroup.children[0];
                cityGroup.remove(obj);
                if (obj.geometry) obj.geometry.dispose();
                if (obj.material) {
                    if (Array.isArray(obj.material)) {
                        obj.material.forEach(m => { if(m.map) m.map.dispose(); m.dispose(); });
                    } else {
                        if (obj.material.map) obj.material.map.dispose();
                        obj.material.dispose();
                    }
                }
            }

            const params = getParams();
            const RND = new PRNG(params.seed);

            const groundGeom = new THREE.PlaneGeometry(params.cityWidth, params.cityDepth);
            const groundMat = new THREE.MeshStandardMaterial({ color: 0x333333 });
            const ground = new THREE.Mesh(groundGeom, groundMat);
            ground.rotation.x = -Math.PI / 2;
            ground.receiveShadow = true;
            cityGroup.add(ground);
            
            const neighborhoodCenters = Object.values(buildingTypes).map(type => ({
                x: RND.random() * params.cityWidth - params.cityWidth / 2,
                z: RND.random() * params.cityDepth - params.cityDepth / 2,
                type: type
            }));

            const blockWidth = (params.cityWidth - (params.blocksX + 1) * params.streetWidth) / params.blocksX;
            const blockDepth = (params.cityDepth - (params.blocksZ + 1) * params.streetWidth) / params.blocksZ;

            for (let i = 0; i < params.blocksX; i++) {
                for (let j = 0; j < params.blocksZ; j++) {
                    const blockCenterX = -params.cityWidth/2 + params.streetWidth * (i + 1) + blockWidth * (i + 0.5);
                    const blockCenterZ = -params.cityDepth/2 + params.streetWidth * (j + 1) + blockDepth * (j + 0.5);
                    
                    let closestDist = Infinity;
                    let blockType = buildingTypes.CONDO;
                    neighborhoodCenters.forEach(center => {
                        const dist = Math.hypot(center.x - blockCenterX, center.z - blockCenterZ);
                        if(dist < closestDist) {
                            closestDist = dist;
                            blockType = center.type;
                        }
                    });

                    placeBuildingsInBlock(blockCenterX, blockCenterZ, blockWidth, blockDepth, blockType, params, RND);
                }
            }
            controls.target.set(0, 0, 0);
            updatePreviews();
        }

        function placeBuildingsInBlock(cx, cz, width, depth, type, params, RND) {
            let subdivisions;
            switch(type) {
                case buildingTypes.SKYSCRAPER: subdivisions = RND.randomInt(1, 2); break;
                case buildingTypes.PALACE:     subdivisions = RND.randomInt(1, 3); break;
                case buildingTypes.CONDO:      subdivisions = RND.randomInt(2, 4); break;
                case buildingTypes.HOUSE:      subdivisions = RND.randomInt(4, 8); break;
                case buildingTypes.INDUSTRY:   subdivisions = RND.randomInt(1, 3); break;
            }

            const plotMargin = 2;
            const rows = Math.round(Math.sqrt(subdivisions));
            const cols = Math.ceil(subdivisions / rows);
            const plotW = (width - plotMargin * (cols - 1)) / cols;
            const plotD = (depth - plotMargin * (rows - 1)) / rows;
            
            for(let i=0, count = 0; i<cols && count < subdivisions; i++){
                for(let j=0; j<rows && count < subdivisions; j++, count++){
                    const plotX = cx - width/2 + i * (plotW + plotMargin) + plotW/2;
                    const plotZ = cz - depth/2 + j * (plotD + plotMargin) + plotD/2;
                    const building = createBuilding(type, plotW * RND.randomRange(0.8, 1.0), plotD * RND.randomRange(0.8, 1.0), params, RND);
                    building.position.set(plotX, 0, plotZ);
                    cityGroup.add(building);
                }
            }
        }
        
        // --- CREAZIONE MODELLI EDIFICI (LOGICA MIGLIORATA) ---
        function createBuilding(type, width, depth, params, RND) {
            const height = params.heights[type] * RND.randomRange(0.7, 1.0);
            
            const baseColors = {
                [buildingTypes.SKYSCRAPER]: 0x8899aa, [buildingTypes.PALACE]: 0xcccccc,
                [buildingTypes.CONDO]: 0xddaa88, [buildingTypes.HOUSE]: 0xffccaa,
                [buildingTypes.INDUSTRY]: 0x777788
            };

            const windowTexture = createWindowTexture(width, height, params, RND);
            const materials = [
                new THREE.MeshStandardMaterial({ map: windowTexture }), // right
                new THREE.MeshStandardMaterial({ map: windowTexture }), // left
                new THREE.MeshStandardMaterial({ color: 0x555555 }),    // top
                new THREE.MeshStandardMaterial({ color: baseColors[type] }), // bottom
                new THREE.MeshStandardMaterial({ map: windowTexture }), // front
                new THREE.MeshStandardMaterial({ map: windowTexture })  // back
            ];

            const buildingGroup = new THREE.Group();
            
            const mainBuildingGeom = new THREE.BoxGeometry(width, height, depth);
            const mainBuilding = new THREE.Mesh(mainBuildingGeom, materials);
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;
            buildingGroup.add(mainBuilding);

            const detailCount = RND.randomInt(1, 5);
            for(let i=0; i<detailCount; i++) {
                const detailW = width * RND.randomRange(0.1, 0.25);
                const detailD = depth * RND.randomRange(0.1, 0.25);
                const detailH = RND.randomRange(2, 8);
                const detailGeom = new THREE.BoxGeometry(detailW, detailH, detailD);
                const detailMat = new THREE.MeshStandardMaterial({color: 0x666666});
                const detailMesh = new THREE.Mesh(detailGeom, detailMat);
                
                detailMesh.position.set(
                    RND.randomRange(-width/2 + detailW/2, width/2 - detailW/2),
                    height + detailH/2,
                    RND.randomRange(-depth/2 + detailD/2, depth/2 - detailD/2)
                );
                detailMesh.castShadow = true;
                buildingGroup.add(detailMesh);
            }

            return buildingGroup;
        }

        function createWindowTexture(buildingWidth, buildingHeight, params, RND) {
            const canvas = document.createElement('canvas');
            const resolutionFactor = 2;
            canvas.width = Math.max(64, Math.floor(buildingWidth * resolutionFactor));
            canvas.height = Math.max(64, Math.floor(buildingHeight * resolutionFactor));
            const context = canvas.getContext('2d');

            context.fillStyle = '#444';
            context.fillRect(0, 0, canvas.width, canvas.height);

            const windowW = 4, windowH = 6, spacingX = 6, spacingY = 8;
            for (let y = spacingY; y < canvas.height - spacingY; y += windowH + spacingY) {
                for (let x = spacingX; x < canvas.width - spacingX; x += windowW + spacingX) {
                    if (RND.random() < params.windowDensity) {
                        context.fillStyle = RND.random() < 0.2 ? '#666' : '#FFFF99';
                        context.fillRect(x, y, windowW, windowH);
                    }
                }
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- GESTIONE ANTEPRIME ---
        function setupPreviews() {
            Object.values(buildingTypes).forEach(type => {
                const container = document.getElementById(`preview-${type}s`);
                if(!container) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x2a3b4c);
                const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
                camera.position.set(40, 50, 60);
                camera.lookAt(0, 20, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);

                scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(30, 50, 40);
                scene.add(light);
                
                const buildingGroup = new THREE.Group();
                scene.add(buildingGroup);

                previewScenes[type] = { scene, camera, renderer, buildingGroup };
            });
        }
        
        function updatePreviews() {
            const params = getParams();
            const RND = new PRNG(params.seed);

            for (const type in previewScenes) {
                const preview = previewScenes[type];
                while(preview.buildingGroup.children.length > 0) {
                    preview.buildingGroup.remove(preview.buildingGroup.children[0]);
                }
                
                const baseWidth = params.heights[type] / 5;
                const building = createBuilding(type, baseWidth, baseWidth, params, RND);
                
                const box = new THREE.Box3().setFromObject(building);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                const scale = 50 / maxDim;
                building.scale.set(scale, scale, scale);
                
                const center = box.getCenter(new THREE.Vector3());
                building.position.sub(center.multiplyScalar(scale));

                preview.buildingGroup.add(building);
            }
        }

        // --- FUNZIONI DI ESPORTAZIONE ---
        function exportImage(scale) {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = `citta_procedurale_${Date.now()}_x${scale}.png`;
            
            if (scale > 1) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                img.onload = () => {
                    canvas.width = img.width * scale;
                    canvas.height = img.height * scale;
                    ctx.drawImage(img, 0, 0, canvas.width, canvas.height);
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                };
                img.src = dataURL;
            } else {
                 link.click();
            }
        }

        function exportPDF() {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/jpeg', 0.8);
            const pdf = new jsPDF({
                orientation: 'landscape', unit: 'px',
                format: [renderer.domElement.width, renderer.domElement.height]
            });
            pdf.addImage(dataURL, 'JPEG', 0, 0, renderer.domElement.width, renderer.domElement.height);
            pdf.save(`citta_procedurale_${Date.now()}.pdf`);
        }

        function exportSVG() {
            const svgRenderer = new SVGRenderer();
            svgRenderer.setSize(window.innerWidth, window.innerHeight);
            svgRenderer.render(scene, camera);
            const svgData = new XMLSerializer().serializeToString(svgRenderer.domElement);
            const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            link.download = `citta_procedurale_${Date.now()}.svg`;
            link.click();
            URL.revokeObjectURL(link.href);
        }

        // --- ANIMAZIONE E GESTIONE FINESTRA ---
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            
            for (const type in previewScenes) {
                const p = previewScenes[type];
                p.buildingGroup.rotation.y += 0.005;
                p.renderer.render(p.scene, p.camera);
            }
        }

        // --- CLASSE HELPER PER NUMERI CASUALI ---
        class PRNG {
            constructor(seed) { this.seed = seed % 2147483647; if (this.seed <= 0) this.seed += 2147483646; }
            next() { return this.seed = (this.seed * 16807) % 2147483647; }
            random() { return (this.next() - 1) / 2147483646; }
            randomInt(min, max) { return Math.floor(this.random() * (max - min + 1)) + min; }
            randomRange(min, max) { return this.random() * (max - min) + min; }
        }

        // --- AVVIO ---
        init();

    </script>
</body>
</html>
