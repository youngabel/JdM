<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Generatore Città v2: Griglia Manhattan</title>
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif; background-color: #111820; color: #fff; overflow: hidden; }
        #scene-container { position: fixed; top: 0; left: 0; width: 100%; height: 100%; }
        #ui-panel { position: fixed; top: 10px; left: 10px; width: 340px; max-height: calc(100% - 20px); background: rgba(0,0,0,0.7); backdrop-filter: blur(10px); border-radius: 8px; padding: 15px; overflow-y: auto; color: #eee; border: 1px solid #444; }
        h2, h3 { margin-top: 0; border-bottom: 1px solid #555; padding-bottom: 5px; }
        .control-group { margin-bottom: 12px; }
        .control-group label { display: block; margin-bottom: 5px; font-size: 14px; }
        .control-group input[type="range"] { width: 100%; }
        .control-group span { float: right; font-weight: bold; }
        button { background-color: #007bff; color: white; border: none; padding: 10px 15px; border-radius: 5px; cursor: pointer; width: 100%; margin-top: 10px; font-weight: bold; transition: background-color 0.2s; }
        button:hover { background-color: #0056b3; }
        .export-buttons { display: flex; gap: 5px; }
        #preview-container { display: grid; grid-template-columns: repeat(auto-fit, minmax(70px, 1fr)); gap: 10px; margin-top: 15px; }
        .preview-box { width: 100%; aspect-ratio: 1; background: #222; border-radius: 4px; border: 1px solid #555; }
        .preview-box canvas { width: 100% !important; height: 100% !important; }
    </style>
</head>
<body>

    <div id="scene-container"></div>

    <div id="ui-panel">
        <h2>Parametri Città</h2>
        <div class="control-group">
            <label>Seme Casuale: <span id="seed-value">1</span></label>
            <input type="range" id="seed" min="1" max="10000" value="1">
        </div>
        <div class="control-group">
            <label>Dimensione Griglia (X): <span id="blocksX-value">10</span></label>
            <input type="range" id="blocksX" min="2" max="30" value="10">
        </div>
        <div class="control-group">
            <label>Dimensione Griglia (Z): <span id="blocksZ-value">10</span></label>
            <input type="range" id="blocksZ" min="2" max="30" value="10">
        </div>
         <div class="control-group">
            <label>Larghezza Strade: <span id="streetWidth-value">15</span></label>
            <input type="range" id="streetWidth" min="5" max="50" value="15">
        </div>
        <div class="control-group">
            <label>Dim. Isolati (X): <span id="blockWidth-value">100</span></label>
            <input type="range" id="blockWidth" min="30" max="300" value="100">
        </div>
         <div class="control-group">
            <label>Dim. Isolati (Z): <span id="blockDepth-value">100</span></label>
            <input type="range" id="blockDepth" min="30" max="300" value="100">
        </div>

        <h3>Edifici per Quartiere</h3>
        <div class="control-group">
            <label>Finestre Illuminate: <span id="windowDensity-value">0.7</span></label>
            <input type="range" id="windowDensity" min="0.1" max="1" value="0.7" step="0.05">
        </div>
        <div class="control-group">
            <label>H Grattacieli: <span id="skyscraperHeight-value">350</span></label>
            <input type="range" id="skyscraperHeight" min="100" max="600" value="350">
        </div>
         <div class="control-group">
            <label>H Distr. Finanziario: <span id="financialHeight-value">250</span></label>
            <input type="range" id="financialHeight" min="100" max="500" value="250">
        </div>
        <div class="control-group">
            <label>H Palazzi: <span id="palaceHeight-value">120</span></label>
            <input type="range" id="palaceHeight" min="50" max="250" value="120">
        </div>
        <div class="control-group">
            <label>H Condomini: <span id="condoHeight-value">60</span></label>
            <input type="range" id="condoHeight" min="20" max="150" value="60">
        </div>
        <div class="control-group">
            <label>H Industrie: <span id="industryHeight-value">45</span></label>
            <input type="range" id="industryHeight" min="15" max="100" value="45">
        </div>
        <div class="control-group">
            <label>H Case: <span id="houseHeight-value">20</span></label>
            <input type="range" id="houseHeight" min="5" max="50" value="20">
        </div>
         <div class="control-group">
            <label>H Residenziale: <span id="suburbanHeight-value">12</span></label>
            <input type="range" id="suburbanHeight" min="5" max="30" value="12">
        </div>
        
        <button id="generate-btn">Genera Nuova Città</button>
        
        <h3>Esporta</h3>
        <div class="export-buttons">
            <button id="export-png-btn">PNG</button>
            <button id="export-hd-png-btn">PNG HD</button>
        </div>

        <h3>Anteprime Modelli</h3>
        <div id="preview-container">
            <div id="preview-skyscrapers" class="preview-box" title="Grattacieli"></div>
            <div id="preview-financials" class="preview-box" title="Distr. Finanziario"></div>
            <div id="preview-palaces" class="preview-box" title="Palazzi"></div>
            <div id="preview-condos" class="preview-box" title="Condomini"></div>
            <div id="preview-industries" class="preview-box" title="Industrie"></div>
            <div id="preview-houses" class="preview-box" title="Case"></div>
            <div id="preview-suburbans" class="preview-box" title="Residenziale"></div>
        </div>
    </div>

    <script type="importmap">
    { "imports": { "three": "https://unpkg.com/three@0.160.0/build/three.module.js", "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/" } }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        // --- VARIABILI GLOBALI ---
        let scene, camera, renderer, controls, cityGroup;
        let crosswalkTexture = null;
        const SCENE_BG_COLOR = 0x111820;
        const SIDEWALK_HEIGHT = 1.0;

        const buildingTypes = {
            SKYSCRAPER: 'skyscraper', FINANCIAL: 'financial', PALACE: 'palace', CONDO: 'condo',
            INDUSTRY: 'industry', HOUSE: 'house', SUBURBAN: 'suburban'
        };
        const previewScenes = {};

        // --- INIZIALIZZAZIONE ---
        function init() {
            scene = new THREE.Scene();
            scene.background = new THREE.Color(SCENE_BG_COLOR);
            scene.fog = new THREE.Fog(SCENE_BG_COLOR, 800, 3000);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 1, 10000);
            camera.position.set(400, 500, 600);

            const container = document.getElementById('scene-container');
            renderer = new THREE.WebGLRenderer({ antialias: true, preserveDrawingBuffer: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            container.appendChild(renderer.domElement);
            
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;

            const ambientLight = new THREE.AmbientLight(0xcedeff, 0.8);
            scene.add(ambientLight);

            const dirLight = new THREE.DirectionalLight(0xffffff, 1.2);
            dirLight.position.set(400, 500, 300);
            dirLight.castShadow = true;
            dirLight.shadow.mapSize.width = 4096;
            dirLight.shadow.mapSize.height = 4096;
            dirLight.shadow.camera.left = -1500;
            dirLight.shadow.camera.right = 1500;
            dirLight.shadow.camera.top = 1500;
            dirLight.shadow.camera.bottom = -1500;
            scene.add(dirLight);

            cityGroup = new THREE.Group();
            scene.add(cityGroup);

            crosswalkTexture = createCrosswalkTexture();

            setupUI();
            setupPreviews();
            generateCity();
            animate();

            window.addEventListener('resize', onWindowResize);
        }

        // --- GESTIONE UI ---
        function setupUI() {
            document.querySelectorAll('input[type="range"]').forEach(slider => {
                document.getElementById(`${slider.id}-value`).textContent = slider.value;
                slider.addEventListener('input', e => {
                    document.getElementById(`${slider.id}-value`).textContent = e.target.value;
                    if (slider.id !== 'seed') generateCity();
                });
                slider.addEventListener('change', () => { if (slider.id === 'seed') generateCity(); });
            });
            document.getElementById('generate-btn').addEventListener('click', () => {
                const seedInput = document.getElementById('seed');
                seedInput.value = Math.floor(Math.random() * 10000) + 1;
                document.getElementById('seed-value').textContent = seedInput.value;
                generateCity();
            });
            document.getElementById('export-png-btn').addEventListener('click', () => exportImage(1));
            document.getElementById('export-hd-png-btn').addEventListener('click', () => exportImage(2.5));
        }
        
        function getParams() {
            const heights = {};
            for (const type of Object.values(buildingTypes)) {
                heights[type] = parseInt(document.getElementById(`${type}Height`).value);
            }
            return {
                seed: parseInt(document.getElementById('seed').value),
                blocksX: parseInt(document.getElementById('blocksX').value),
                blocksZ: parseInt(document.getElementById('blocksZ').value),
                streetWidth: parseInt(document.getElementById('streetWidth').value),
                blockWidth: parseInt(document.getElementById('blockWidth').value),
                blockDepth: parseInt(document.getElementById('blockDepth').value),
                windowDensity: parseFloat(document.getElementById('windowDensity').value),
                heights
            };
        }

        // --- LOGICA DI GENERAZIONE CITTÀ ---
        function generateCity() {
            // Pulizia efficiente della scena
            while (cityGroup.children.length > 0) {
                const obj = cityGroup.children[0];
                cityGroup.remove(obj);
                if (obj.traverse) {
                    obj.traverse(child => {
                        if (child.isMesh) {
                            child.geometry.dispose();
                            if (Array.isArray(child.material)) {
                                child.material.forEach(m => { if(m.map) m.map.dispose(); m.dispose(); });
                            } else if (child.material) {
                                if (child.material.map) child.material.map.dispose();
                                child.material.dispose();
                            }
                        }
                    });
                }
            }

            const params = getParams();
            const RND = new PRNG(params.seed);

            const totalWidth = params.blocksX * params.blockWidth + (params.blocksX - 1) * params.streetWidth;
            const totalDepth = params.blocksZ * params.blockDepth + (params.blocksZ - 1) * params.streetWidth;

            // 1. Base stradale (asfalto)
            const roadGeom = new THREE.PlaneGeometry(totalWidth + params.streetWidth, totalDepth + params.streetWidth);
            const roadMat = new THREE.MeshStandardMaterial({ color: 0x282828 });
            const roadPlane = new THREE.Mesh(roadGeom, roadMat);
            roadPlane.rotation.x = -Math.PI / 2;
            roadPlane.receiveShadow = true;
            cityGroup.add(roadPlane);

            const neighborhoodCenters = Object.values(buildingTypes).map(type => ({
                x: RND.random() * totalWidth - totalWidth / 2,
                z: RND.random() * totalDepth - totalDepth / 2,
                type
            }));

            // Materiali comuni
            const sidewalkMat = new THREE.MeshStandardMaterial({ color: 0x999999 });
            const crosswalkMat = new THREE.MeshStandardMaterial({ map: crosswalkTexture, transparent: true });

            // 2. Itera e crea isolati, marciapiedi e strisce
            for (let i = 0; i < params.blocksX; i++) {
                for (let j = 0; j < params.blocksZ; j++) {
                    const blockCenterX = -totalWidth/2 + params.blockWidth/2 + i * (params.blockWidth + params.streetWidth);
                    const blockCenterZ = -totalDepth/2 + params.blockDepth/2 + j * (params.blockDepth + params.streetWidth);
                    
                    // Crea il basamento/marciapiede
                    const sidewalkGeom = new THREE.BoxGeometry(params.blockWidth, SIDEWALK_HEIGHT, params.blockDepth);
                    const sidewalk = new THREE.Mesh(sidewalkGeom, sidewalkMat);
                    sidewalk.position.set(blockCenterX, SIDEWALK_HEIGHT/2, blockCenterZ);
                    sidewalk.receiveShadow = true;
                    cityGroup.add(sidewalk);

                    // Determina quartiere
                    let closestDist = Infinity, blockType = buildingTypes.CONDO;
                    neighborhoodCenters.forEach(center => {
                        const dist = Math.hypot(center.x - blockCenterX, center.z - blockCenterZ);
                        if(dist < closestDist) {
                            closestDist = dist; blockType = center.type;
                        }
                    });
                    
                    placeBuildingsInBlock(blockCenterX, blockCenterZ, params.blockWidth, params.blockDepth, blockType, params, RND);

                    // 3. Aggiungi strisce pedonali agli incroci
                    if (i < params.blocksX - 1 && j < params.blocksZ - 1) {
                        const intersectionX = blockCenterX + params.blockWidth / 2 + params.streetWidth / 2;
                        const intersectionZ = blockCenterZ + params.blockDepth / 2 + params.streetWidth / 2;
                        addCrosswalks(intersectionX, intersectionZ, params.streetWidth);
                    }
                }
            }
            controls.target.set(0, 0, 0);
            updatePreviews();
        }

        function addCrosswalks(x, z, streetWidth) {
            const crosswalkGeom = new THREE.PlaneGeometry(streetWidth, streetWidth / 2.5);
            const crosswalkMat = new THREE.MeshStandardMaterial({ map: crosswalkTexture, transparent: true });

            const posOffset = streetWidth / 2;
            const heightOffset = 0.1; // Leggermente sopra l'asfalto per evitare z-fighting

            // Striscia +Z
            const cw1 = new THREE.Mesh(crosswalkGeom, crosswalkMat);
            cw1.position.set(x - posOffset, heightOffset, z);
            cw1.rotation.x = -Math.PI / 2;
            cityGroup.add(cw1);

            // Striscia -Z
            const cw2 = new THREE.Mesh(crosswalkGeom, crosswalkMat);
            cw2.position.set(x + posOffset, heightOffset, z);
            cw2.rotation.x = -Math.PI / 2;
            cw2.rotation.z = Math.PI;
            cityGroup.add(cw2);

             // Striscia +X
            const cw3 = new THREE.Mesh(crosswalkGeom, crosswalkMat);
            cw3.position.set(x, heightOffset, z + posOffset);
            cw3.rotation.x = -Math.PI / 2;
            cw3.rotation.z = Math.PI / 2;
            cityGroup.add(cw3);

            // Striscia -X
            const cw4 = new THREE.Mesh(crosswalkGeom, crosswalkMat);
            cw4.position.set(x, heightOffset, z - posOffset);
            cw4.rotation.x = -Math.PI / 2;
            cw4.rotation.z = -Math.PI / 2;
            cityGroup.add(cw4);
        }

        function placeBuildingsInBlock(cx, cz, width, depth, type, params, RND) {
            let subdivisions;
            switch(type) {
                case buildingTypes.SKYSCRAPER: subdivisions = RND.randomInt(1, 2); break;
                case buildingTypes.FINANCIAL:  subdivisions = RND.randomInt(1, 3); break;
                case buildingTypes.PALACE:     subdivisions = RND.randomInt(2, 4); break;
                case buildingTypes.CONDO:      subdivisions = RND.randomInt(2, 5); break;
                case buildingTypes.INDUSTRY:   subdivisions = RND.randomInt(1, 4); break;
                case buildingTypes.HOUSE:      subdivisions = RND.randomInt(4, 9); break;
                case buildingTypes.SUBURBAN:   subdivisions = RND.randomInt(5, 12); break;
                default: subdivisions = 3;
            }

            const plotMargin = 2;
            const rows = Math.round(Math.sqrt(subdivisions));
            const cols = Math.ceil(subdivisions / rows);
            const plotW = (width - plotMargin * (cols + 1)) / cols;
            const plotD = (depth - plotMargin * (rows + 1)) / rows;
            
            for(let i=0, count = 0; i<cols && count < subdivisions; i++){
                for(let j=0; j<rows && count < subdivisions; j++, count++){
                    const plotX = cx - width/2 + plotMargin + i * (plotW + plotMargin) + plotW/2;
                    const plotZ = cz - depth/2 + plotMargin + j * (plotD + plotMargin) + plotD/2;
                    const building = createBuilding(type, plotW * RND.randomRange(0.85, 1.0), plotD * RND.randomRange(0.85, 1.0), params, RND);
                    building.position.set(plotX, SIDEWALK_HEIGHT, plotZ);
                    cityGroup.add(building);
                }
            }
        }
        
        // --- CREAZIONE MODELLI EDIFICI ---
        function createBuilding(type, width, depth, params, RND) {
            const height = params.heights[type] * RND.randomRange(0.7, 1.0);
            
            const baseColors = {
                [buildingTypes.SKYSCRAPER]: 0x8899aa, [buildingTypes.FINANCIAL]: 0xaaccf0, [buildingTypes.PALACE]: 0xcccccc,
                [buildingTypes.CONDO]: 0xddaa88, [buildingTypes.HOUSE]: 0xffccaa, [buildingTypes.INDUSTRY]: 0x9999aa,
                [buildingTypes.SUBURBAN]: 0xddeeff
            };

            const windowTexture = createWindowTexture(width, height, params, RND);
            const sideMat = new THREE.MeshStandardMaterial({ map: windowTexture });
            const roofMat = new THREE.MeshStandardMaterial({ color: 0x555555 });
            const bottomMat = new THREE.MeshStandardMaterial({ color: baseColors[type] });
            
            const mainBuilding = new THREE.Mesh(
                new THREE.BoxGeometry(width, height, depth),
                [sideMat, sideMat, roofMat, bottomMat, sideMat, sideMat]
            );
            mainBuilding.position.y = height / 2;
            mainBuilding.castShadow = true;
            mainBuilding.receiveShadow = true;

            const buildingGroup = new THREE.Group();
            buildingGroup.add(mainBuilding);

            const detailCount = RND.randomInt(0, 5);
            for(let i=0; i<detailCount; i++) {
                const detailW = width * RND.randomRange(0.1, 0.3);
                const detailD = depth * RND.randomRange(0.1, 0.3);
                const detailH = RND.randomRange(2, 10);
                const detailGeom = new THREE.BoxGeometry(detailW, detailH, detailD);
                const detailMat = new THREE.MeshStandardMaterial({color: 0x666666});
                const detailMesh = new THREE.Mesh(detailGeom, detailMat);
                
                detailMesh.position.set(
                    RND.randomRange(-width/2 + detailW/2, width/2 - detailW/2),
                    height + detailH/2,
                    RND.randomRange(-depth/2 + detailD/2, depth/2 - detailD/2)
                );
                detailMesh.castShadow = true;
                buildingGroup.add(detailMesh);
            }
            return buildingGroup;
        }

        // --- FUNZIONI TEXTURE ---
        function createWindowTexture(buildingWidth, buildingHeight, params, RND) {
            const canvas = document.createElement('canvas');
            canvas.width = Math.max(64, Math.floor(buildingWidth * 2));
            canvas.height = Math.max(64, Math.floor(buildingHeight * 2));
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = '#444';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            const windowW = 4, windowH = 6, spacingX = 6, spacingY = 8;
            for (let y = spacingY; y < canvas.height - spacingY; y += windowH + spacingY) {
                for (let x = spacingX; x < canvas.width - spacingX; x += windowW + spacingX) {
                    if (RND.random() < params.windowDensity) {
                        ctx.fillStyle = RND.random() < 0.25 ? '#555' : '#FFFF99';
                        ctx.fillRect(x, y, windowW, windowH);
                    }
                }
            }
            return new THREE.CanvasTexture(canvas);
        }

        function createCrosswalkTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128; canvas.height = 64;
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = "rgba(0, 0, 0, 0)"; // Sfondo trasparente
            ctx.fillRect(0, 0, 128, 64);
            ctx.fillStyle = "white";
            for (let i = 0; i < 7; i++) {
                ctx.fillRect(i * 18 + 5, 0, 10, 64);
            }
            return new THREE.CanvasTexture(canvas);
        }

        // --- GESTIONE ANTEPRIME ---
        function setupPreviews() {
            Object.values(buildingTypes).forEach(type => {
                const container = document.getElementById(`preview-${type}s`);
                if(!container) return;

                const scene = new THREE.Scene();
                scene.background = new THREE.Color(0x2a3b4c);
                const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
                camera.position.set(40, 50, 60);
                camera.lookAt(0, 20, 0);

                const renderer = new THREE.WebGLRenderer({ antialias: true });
                renderer.setSize(container.clientWidth, container.clientHeight);
                container.appendChild(renderer.domElement);
                scene.add(new THREE.AmbientLight(0xffffff, 0.8));
                const light = new THREE.DirectionalLight(0xffffff, 1);
                light.position.set(30, 50, 40);
                scene.add(light);
                const buildingGroup = new THREE.Group();
                scene.add(buildingGroup);
                previewScenes[type] = { scene, camera, renderer, buildingGroup };
            });
        }
        
        function updatePreviews() {
            const params = getParams();
            const RND = new PRNG(params.seed);
            for (const type in previewScenes) {
                const preview = previewScenes[type];
                while(preview.buildingGroup.children.length > 0) {
                    preview.buildingGroup.remove(preview.buildingGroup.children[0]);
                }
                const baseWidth = params.heights[type] / 4;
                const building = createBuilding(type, baseWidth, baseWidth, params, RND);
                const box = new THREE.Box3().setFromObject(building);
                const size = box.getSize(new THREE.Vector3());
                const maxDim = Math.max(size.x, size.y, size.z);
                building.scale.multiplyScalar(50 / maxDim);
                const center = box.getCenter(new THREE.Vector3());
                building.position.sub(center.multiplyScalar(50 / maxDim));
                preview.buildingGroup.add(building);
            }
        }

        // --- UTILITY ---
        function exportImage(scale) {
            renderer.render(scene, camera);
            const dataURL = renderer.domElement.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `citta_procedurale_${Date.now()}.png`;
            
            if (scale !== 1) {
                const img = new Image();
                img.onload = () => {
                    const canvas = document.createElement('canvas');
                    canvas.width = renderer.domElement.width * scale;
                    canvas.height = renderer.domElement.height * scale;
                    canvas.getContext('2d').drawImage(img, 0, 0, canvas.width, canvas.height);
                    link.href = canvas.toDataURL('image/png');
                    link.click();
                };
                img.src = dataURL;
            } else {
                 link.href = dataURL; link.click();
            }
        }
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
            for (const type in previewScenes) {
                const p = previewScenes[type];
                p.buildingGroup.rotation.y += 0.005;
                p.renderer.render(p.scene, p.camera);
            }
        }
        class PRNG {
            constructor(seed) { this.seed = seed % 2147483647; if (this.seed <= 0) this.seed += 2147483646; }
            next() { return this.seed = (this.seed * 16807) % 2147483647; }
            random() { return (this.next() - 1) / 2147483646; }
            randomInt(min, max) { return Math.floor(this.random() * (max - min + 1)) + min; }
            randomRange(min, max) { return this.random() * (max - min) + min; }
        }

        init();
    </script>
</body>
</html>
