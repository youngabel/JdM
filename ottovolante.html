<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ottovolante Avanzato</title>
    <style>
        body { margin: 0; overflow: hidden; background-color: #111; }
        canvas { display: block; }
        #controls {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0, 0, 0, 0.6);
            padding: 10px 20px;
            border-radius: 10px;
            color: white;
            font-family: sans-serif;
            text-align: center;
        }
        label { margin-right: 10px; }
        input[type="range"] { width: 200px; }
        p { margin: 5px 0 0 0; }
    </style>
</head>
<body>
    <div id="controls">
        <label for="speedSlider">Velocità:</label>
        <input type="range" id="speedSlider" min="0.1" max="5" value="1" step="0.1">
        <p>Tieni premuto 'F' per frenare</p>
        <p>Premi 'C' per cambiare visuale</p>
        <p>Premi 'N' per il tracciato successivo</p>
        <p>Nella visuale statica: usa le frecce direzionali per muoverti</p>
    </div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';

        // --- SETUP SCENA ---
        const scene = new THREE.Scene();
        scene.fog = new THREE.Fog(0x111111, 10, 200);
        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        const renderer = new THREE.WebGLRenderer({ antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.body.appendChild(renderer.domElement);
        const ambientLight = new THREE.AmbientLight(0xcccccc, 0.5);
        scene.add(ambientLight);
        const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
        directionalLight.position.set(1, 1, 0).normalize();
        scene.add(directionalLight);
        
        // --- DEFINIZIONE DELLE CURVE ---
        const tMin = 0;
        const tMax = 2 * Math.PI;
        const curveDefinitions = [
            {
                name: "Lissajous 3D",
                func: (t) => new THREE.Vector3(Math.sin(t) * 20 + Math.sin(3 * t) * 5, Math.cos(t) * 10 + Math.sin(2 * t) * 5 + 10, Math.cos(3 * t) * 15)
            },
            {
                name: "Doppia Elica",
                func: (t) => new THREE.Vector3(Math.cos(t * 2) * 25, t * 4, Math.sin(t * 2) * 25)
            },
            {
                name: "Figura a Otto 'Knot'",
                func: (t) => {
                    t *= 2;
                    return new THREE.Vector3((2 + Math.cos(2 * t)) * Math.cos(3 * t) * 15, (2 + Math.cos(2 * t)) * Math.sin(3 * t) * 15, Math.sin(2 * t) * 10 + 5);
                }
            },
            {
                name: "Nodo Toroidale (Trefoil)",
                func: (t) => new THREE.Vector3((20 + 5 * Math.cos(3 * t)) * Math.cos(2 * t), (20 + 5 * Math.cos(3 * t)) * Math.sin(2 * t), 5 * Math.sin(3 * t) + 8)
            },
            {
                name: "Spirale Conica",
                func: (t) => new THREE.Vector3((5 + 15 * (1 - (t / tMax))) * Math.cos(t * 5), t * 6, (5 + 15 * (1 - (t / tMax))) * Math.sin(t * 5))
            },
            {
                name: "Curva a Farfalla 3D",
                func: (t) => {
                    const T = t * 6;
                    const r = Math.exp(Math.sin(T)) - 2 * Math.cos(4 * T) + Math.pow(Math.sin((2 * T - Math.PI) / 24), 5);
                    return new THREE.Vector3(Math.sin(T) * r * 3, Math.cos(T) * r * 3 + 15, Math.cos(T / 2) * 10);
                }
            }
        ];
        let currentCurveIndex = 0;
        let track;

        function buildTrack(curveFunc) {
            if (track) { scene.remove(track); track.geometry.dispose(); track.material.dispose(); }
            const points = [];
            for (let i = 0; i <= 500; i++) {
                points.push(curveFunc(tMin + (tMax - tMin) * (i / 500)));
            }
            track = new THREE.Mesh(new THREE.TubeGeometry(new THREE.CatmullRomCurve3(points), 500, 0.2, 8, false), new THREE.MeshLambertMaterial({ color: 0x808080 }));
            scene.add(track);
        }

        // --- OGGETTO IN MOVIMENTO ---
        const cart = new THREE.Mesh(new THREE.SphereGeometry(0.5, 16, 16), new THREE.MeshBasicMaterial({ color: 0xff0000 }));
        scene.add(cart);

        // --- HELPER PER LA TERNA DI FRENET ---
        const arrowLength = 5;
        const tangentArrow = new THREE.ArrowHelper(new THREE.Vector3(1, 0, 0), cart.position, arrowLength, 0xff0000); // Rosso (Tangente)
        const normalArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 1, 0), cart.position, arrowLength, 0x00ff00); // Verde (Normale)
        const binormalArrow = new THREE.ArrowHelper(new THREE.Vector3(0, 0, 1), cart.position, arrowLength, 0x0000ff); // Blu (Binormale)
        scene.add(tangentArrow, normalArrow, binormalArrow);

        // --- ★ NUOVO: PIANO OSCULATORE ---
        const planeGeometry = new THREE.PlaneGeometry(15, 15); // Un piano 15x15
        const planeMaterial = new THREE.MeshBasicMaterial({ color: 0xffff00, side: THREE.DoubleSide, transparent: true, opacity: 0.2 }); // Giallo semi-trasparente
        const osculatingPlane = new THREE.Mesh(planeGeometry, planeMaterial);
        scene.add(osculatingPlane);

        // --- VARIABILI DI STATO ---
        let t = tMin;
        let speed = 0.02;
        let speedMultiplier = 1;
        let isBraking = false;
        let cameraMode = 0;
        const frenetFrame = { tangent: new THREE.Vector3(), normal: new THREE.Vector3(), binormal: new THREE.Vector3() };

        // --- ★ NUOVO: VARIABILI PER IL MOVIMENTO DELL'OSSERVATORE ---
        let staticCamPos = new THREE.Vector3(50, 15, 50); // Posizione iniziale dell'osservatore
        const staticCamSpeed = 1; // Velocità di movimento
        const keys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

        // --- FUNZIONI DI CALCOLO E ANIMAZIONE ---
        function getCurrentCurve() { return curveDefinitions[currentCurveIndex].func; }

        function updateFrenetFrame(t_current) {
            const epsilon = 0.0001;
            const curveFunc = getCurrentCurve();
            const p1 = curveFunc(t_current);
            const p2 = curveFunc(t_current + epsilon);
            frenetFrame.tangent.subVectors(p2, p1).normalize();
            const p0 = curveFunc(t_current - epsilon);
            const tangent_prev = new THREE.Vector3().subVectors(p1, p0).normalize();
            frenetFrame.normal.subVectors(frenetFrame.tangent, tangent_prev).normalize();
            frenetFrame.binormal.crossVectors(frenetFrame.tangent, frenetFrame.normal).normalize();
        }

        // --- ★ NUOVO: CREAZIONE TESTO 3D ---
        const fontLoader = new FontLoader();
        let titleMesh, subtitleMesh, docenteMesh, istitutoMesh;

        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_regular.typeface.json', function (font) {
            const textMaterial = new THREE.MeshLambertMaterial({ color: 0xeeeeee });

            function createText(text, size, height, position, rotationY = 0) {
                const geometry = new TextGeometry(text, {
                    font: font,
                    size: size,
                    height: height,
                    curveSegments: 12,
                    bevelEnabled: false
                });
                geometry.computeBoundingBox();
                const centerOffset = -0.5 * (geometry.boundingBox.max.x - geometry.boundingBox.min.x);
                const mesh = new THREE.Mesh(geometry, textMaterial);
                mesh.position.set(position.x + centerOffset, position.y, position.z);
                mesh.rotation.y = rotationY;
                scene.add(mesh);
                return mesh;
            }

            titleMesh = createText("OTTOVOLANTE 3D", 8, 1, new THREE.Vector3(0, 40, -100));
            subtitleMesh = createText("A ogni Curva e la sua terna di Frenet", 4, 0.5, new THREE.Vector3(0, 30, -100));
            docenteMesh = createText("Docente: [Bertazzo N.]", 3, 0.3, new THREE.Vector3(0, -20, -100));
            istitutoMesh = createText("Istituto: [IIS JdM]", 3, 0.3, new THREE.Vector3(0, -25, -100));

            // Per allineare meglio il testo se necessario:
            // titleMesh.position.x -= titleMesh.geometry.boundingBox.max.x / 2;
            // subtitleMesh.position.x -= subtitleMesh.geometry.boundingBox.max.x / 2;
            // docenteMesh.position.x -= docenteMesh.geometry.boundingBox.max.x / 2;
            // istitutoMesh.position.x -= istitutoMesh.geometry.boundingBox.max.x / 2;
        });

        function animate() {
            requestAnimationFrame(animate);
            const currentSpeed = (isBraking ? 0.1 : speedMultiplier) * speed;
            t += currentSpeed;
            if (t > tMax) t = tMin + (t - tMax);

            const curveFunc = getCurrentCurve();
            updateFrenetFrame(t);
            const position = curveFunc(t);
            cart.position.copy(position);

            // --- Aggiornamento e Visibilità della Terna di Frenet e Piano Osculatore ---
            const areHelpersVisible = (cameraMode === 2);

            tangentArrow.position.copy(position);
            normalArrow.position.copy(position);
            binormalArrow.position.copy(position);
            tangentArrow.setDirection(frenetFrame.tangent);
            normalArrow.setDirection(frenetFrame.normal);
            binormalArrow.setDirection(frenetFrame.binormal);
            
            tangentArrow.visible = areHelpersVisible;
            normalArrow.visible = areHelpersVisible;
            binormalArrow.visible = areHelpersVisible;

            // Aggiornamento del piano osculatore
            osculatingPlane.position.copy(position);
            if (frenetFrame.normal.length() > 0 && frenetFrame.tangent.length() > 0) { // Assicurati che i vettori siano validi
                // Crea una matrice di rotazione dal vettore tangente e normale
                const rotationMatrix = new THREE.Matrix4();
                rotationMatrix.lookAt(frenetFrame.tangent, new THREE.Vector3(0,0,0), frenetFrame.normal); // 'up' vector è la normale
                osculatingPlane.quaternion.setFromRotationMatrix(rotationMatrix);
                osculatingPlane.quaternion.multiply(new THREE.Quaternion().setFromAxisAngle(new THREE.Vector3(0,1,0), -Math.PI/2)); // Orienta correttamente il piano
            }
            osculatingPlane.visible = areHelpersVisible;

            // --- GESTIONE DELLA TELECAMERA ---
            switch (cameraMode) {
                case 0: { // POV
                    camera.position.copy(position.clone().add(new THREE.Vector3(0, 1.5, 0)));
                    camera.lookAt(position.clone().add(frenetFrame.tangent.clone().multiplyScalar(10)));
                    camera.up.copy(frenetFrame.normal);
                    break;
                }
                case 1: { // Third Person
                    const offset = frenetFrame.tangent.clone().multiplyScalar(-12).add(new THREE.Vector3(0, 4, 0));
                    camera.position.copy(position.clone().add(offset));
                    camera.lookAt(position);
                    camera.up.copy(frenetFrame.normal);
                    break;
                }
                case 2: { // Static (Osservatore Muovibile)
                    // --- ★ NUOVO: MOVIMENTO TELECAMERA OSSERVATORE ---
                    let moveX = 0;
                    let moveZ = 0;

                    if (keys.ArrowUp) moveZ -= staticCamSpeed;
                    if (keys.ArrowDown) moveZ += staticCamSpeed;
                    if (keys.ArrowLeft) moveX -= staticCamSpeed;
                    if (keys.ArrowRight) moveX += staticCamSpeed;

                    // Muovi la telecamera basandoti sulle direzioni locali relative al suo orientamento
                    // Per camminare sul piano Z=0, muoviamo semplicemente sugli assi X e Z globali
                    staticCamPos.x += moveX;
                    staticCamPos.z += moveZ;
                    
                    camera.position.copy(staticCamPos);
                    camera.lookAt(new THREE.Vector3(0, 10, 0)); // Continua a guardare un punto centrale
                    camera.up.set(0, 1, 0); // Mantiene la camera dritta
                    break;
                }
            }
            renderer.render(scene, camera);
        }

        // --- GESTIONE INPUT UTENTE ---
        document.getElementById('speedSlider').addEventListener('input', (e) => speedMultiplier = parseFloat(e.target.value));

        window.addEventListener('keydown', (e) => {
            const key = e.key;
            if (key.toLowerCase() === 'f') isBraking = true;
            if (key.toLowerCase() === 'c') cameraMode = (cameraMode + 1) % 3;
            if (key.toLowerCase() === 'n') {
                currentCurveIndex = (currentCurveIndex + 1) % curveDefinitions.length;
                buildTrack(getCurrentCurve());
                t = tMin;
            }
            if (keys.hasOwnProperty(key)) {
                keys[key] = true;
            }
        });

        window.addEventListener('keyup', (e) => {
            const key = e.key;
            if (key.toLowerCase() === 'f') isBraking = false;
            if (keys.hasOwnProperty(key)) {
                keys[key] = false;
            }
        });

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- INIZIALIZZAZIONE ---
        buildTrack(getCurrentCurve());
        animate();
    </script>
</body>
</html>
